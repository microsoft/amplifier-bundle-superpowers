# Subagent-Driven Development Workflow
# A sophisticated implementation workflow that dispatches fresh agents per task,
# with two-stage review after each: spec compliance first, then code quality.
#
# Key Features:
#   - Fresh agent per task (no context pollution between tasks)
#   - Per-task sequential pipeline (implement -> spec-review loop -> quality-review loop)
#   - Review convergence loops iterate until APPROVED
#   - Human approval gate after final review before finishing
#
# Workflow:
#   For EACH task:
#     1. Dispatch fresh implementer agent (TDD approach)
#     2. Spec compliance review - iterate until spec-compliant
#     3. Code quality review - iterate until approved
#     4. Mark task complete
#   After ALL tasks:
#     5. Full code review of entire implementation
#     6. APPROVAL GATE - human checkpoint
#     7. Verify tests and present merge options
#
# Usage:
#   amplifier run "execute superpowers:recipes/subagent-driven-development.yaml with plan_path=docs/implementation-plan.md"
#
# After the approval gate:
#   amplifier run "list pending approvals"
#   amplifier run "approve recipe session <session-id> stage final-review"
#   amplifier run "resume recipe session <session-id>"

name: "subagent-driven-development"
description: "Execute implementation plan with fresh agents per task and two-stage review (spec compliance then code quality)"
version: "3.0.0"
author: "Superpowers Bundle"
tags: ["implementation", "subagent", "tdd", "two-stage-review", "code-quality", "foreach", "per-task-pipeline"]

context:
  plan_path: ""  # Required: Path to the implementation plan file

stages:
  # ============================================================================
  # STAGE 1: Task Execution
  # Dispatch fresh agents to implement each task with two-stage review
  # ============================================================================
  - name: "task-execution"
    steps:
      # -----------------------------------------------------------------------
      # Step 1: Load and Parse Implementation Plan
      # -----------------------------------------------------------------------
      - id: "load-plan"
        agent: "superpowers:plan-writer"
        prompt: |
          Load the implementation plan from: {{plan_path}}

          Parse the plan and extract all implementation tasks as a structured list.

          For each task, extract:
          - task_id: Unique identifier or name
          - description: What needs to be implemented
          - spec: The detailed specification/requirements
          - acceptance_criteria: How to verify the task is complete
          - files: Files likely to be created or modified
          - dependencies: Any tasks this depends on (if applicable)

          Return the tasks as a JSON array that can be iterated.
          Order tasks by dependencies (independent tasks first, dependent tasks later).

          IMPORTANT: Preserve ALL spec details - they are critical for review.
        output: "tasks"
        parse_json: true
        timeout: 300

      # -----------------------------------------------------------------------
      # Step 2: Per-Task Pipeline (implement -> spec-review -> quality-review)
      # Each task goes through the FULL pipeline before the next task starts.
      # -----------------------------------------------------------------------
      - id: "per-task-pipeline"
        foreach: "{{tasks}}"
        as: "current_task"
        steps:
          # --- 2a: Implement the task ---
          - id: "implement"
            agent: "superpowers:implementer"
            prompt: |
              SUBAGENT IMPLEMENTATION TASK
              ============================

              You are a fresh agent assigned to implement ONE specific task.
              Focus ONLY on this task. Do not consider other tasks.

              TASK TO IMPLEMENT:
              {{current_task}}

              IMPLEMENTATION REQUIREMENTS:
              1. FOLLOW TDD (Test-Driven Development):
                 - Write failing tests FIRST based on the spec
                 - Implement code to make tests pass
                 - Refactor if needed while keeping tests green
              2. FOLLOW THE SPEC EXACTLY:
                 - Implement exactly what the spec says
                 - Do not add features not in the spec
                 - Do not skip any spec requirements
              3. VERIFY BEFORE COMPLETING:
                 - Run the tests you wrote
                 - Confirm they pass
                 - Commit your changes

              OUTPUT FORMAT:
              Return your implementation results including:
              - task_id: Which task was implemented
              - files_changed: [list of files created/modified]
              - tests_written: [list of test files/functions]
              - test_results: pass/fail with details
              - implementation_notes: Key decisions or notes
              - spec_coverage: How each spec requirement was addressed
            output: "task_implementation"
            timeout: 900  # 15 minutes per task

          # --- 2b: Spec compliance review loop ---
          - id: "spec-review-loop"
            while_condition: "true"
            break_when: "{{spec_verdict}} contains APPROVED"
            max_iterations: 3
            steps:
              - id: "spec-review"
                agent: "superpowers:spec-reviewer"
                prompt: |
                  SPEC COMPLIANCE REVIEW
                  ======================
                  Review Stage 1 of 2: Verify implementation matches specification EXACTLY.

                  TASK SPEC:
                  {{current_task}}

                  IMPLEMENTATION RESULT:
                  {{task_implementation}}

                  YOUR MISSION:
                  1. Read the ACTUAL CODE (do not trust the implementation report)
                  2. Compare every spec requirement against what was implemented
                  3. Run the test suite and read the full output
                  4. Check for missing requirements AND extra features

                  VERDICT FORMAT:
                  End your review with exactly one of:
                  - "VERDICT: APPROVED" — spec fully implemented, nothing extra
                  - "VERDICT: NEEDS CHANGES — [list specific issues]"
                output: "spec_verdict"
                timeout: 600

              - id: "spec-fix"
                condition: "{{spec_verdict}} contains NEEDS CHANGES"
                agent: "superpowers:implementer"
                prompt: |
                  SPEC COMPLIANCE FIX
                  ====================
                  The spec reviewer found issues with your implementation.

                  REVIEW FEEDBACK:
                  {{spec_verdict}}

                  ORIGINAL TASK:
                  {{current_task}}

                  Fix ONLY the issues identified. Do not add anything else.
                  Run tests after fixing. Commit your changes.

                  Return updated implementation results.
                output: "task_implementation"
                timeout: 600

          # --- 2c: Code quality review loop ---
          - id: "quality-review-loop"
            while_condition: "true"
            break_when: "{{quality_verdict}} contains APPROVED"
            max_iterations: 3
            steps:
              - id: "quality-review"
                agent: "superpowers:code-quality-reviewer"
                prompt: |
                  CODE QUALITY REVIEW
                  ===================
                  Review Stage 2 of 2: Verify code quality and best practices.
                  Spec compliance has already been verified.

                  TASK:
                  {{current_task}}

                  IMPLEMENTATION:
                  {{task_implementation}}

                  YOUR MISSION:
                  1. Read the ACTUAL CODE
                  2. Run the test suite and read the full output
                  3. Check: clean code, DRY, error handling, test quality, maintainability
                  4. Do NOT change spec behavior — only refactor for quality

                  VERDICT FORMAT:
                  End your review with exactly one of:
                  - "VERDICT: APPROVED" — code quality meets standards
                  - "VERDICT: NEEDS CHANGES — [list specific issues by severity]"

                  Minor/suggestion issues do NOT block approval.
                  Only critical and major issues require NEEDS CHANGES.
                output: "quality_verdict"
                timeout: 600

              - id: "quality-fix"
                condition: "{{quality_verdict}} contains NEEDS CHANGES"
                agent: "superpowers:implementer"
                prompt: |
                  CODE QUALITY FIX
                  =================
                  The code quality reviewer found issues.

                  REVIEW FEEDBACK:
                  {{quality_verdict}}

                  ORIGINAL TASK:
                  {{current_task}}

                  Fix ONLY the quality issues identified. Do NOT change spec behavior.
                  Run tests after fixing. Commit your changes.

                  Return updated implementation results.
                output: "task_implementation"
                timeout: 600

        collect: "completed_tasks"

      # -----------------------------------------------------------------------
      # Step 3: Task Completion Summary
      # -----------------------------------------------------------------------
      - id: "task-summary"
        agent: "superpowers:plan-writer"
        prompt: |
          TASK EXECUTION SUMMARY
          ======================
          Compile a summary of all completed tasks.

          COMPLETED TASKS:
          {{completed_tasks}}

          ORIGINAL TASKS:
          {{tasks}}

          Create a comprehensive summary including:

          ## Completion Status
          - Total tasks: [count]
          - Successfully completed: [count]

          ## Per-Task Summary
          For each task:
          - Task ID/Name
          - Spec compliance: approved (with iteration count if > 1)
          - Code quality: approved (with iteration count if > 1)
          - Files modified

          ## Issues Resolved
          Summary of issues found and fixed during reviews.
        output: "execution_summary"
        timeout: 300

  # ============================================================================
  # STAGE 2: Final Review (APPROVAL GATE)
  # Full code review of the entire implementation before finishing
  # ============================================================================
  - name: "final-review"
    steps:
      - id: "full-code-review"
        agent: "superpowers:code-quality-reviewer"
        prompt: |
          FINAL COMPREHENSIVE CODE REVIEW
          ================================
          Review the ENTIRE implementation across all tasks.

          EXECUTION SUMMARY:
          {{execution_summary}}

          COMPLETED TASKS:
          {{completed_tasks}}

          ORIGINAL PLAN:
          {{plan_path}}

          This is the final review before the implementation is considered complete.
          Look at the implementation HOLISTICALLY, not just individual tasks.

          REVIEW AREAS:
          1. CROSS-CUTTING CONCERNS
             - Are there patterns that should be unified?
             - Any inconsistencies between tasks?
             - Shared utilities that should be extracted?
          2. INTEGRATION
             - Do all tasks work together correctly?
             - Any integration issues between components?
             - Are interfaces consistent?
          3. ARCHITECTURE
             - Does the overall structure make sense?
             - Are dependencies appropriate?
             - Is the code organized logically?
          4. TEST COVERAGE
             - Is there adequate integration testing?
             - Any gaps in test coverage?
             - Are edge cases handled?
          5. DOCUMENTATION
             - Is code self-documenting?
             - Any complex logic that needs comments?
             - Is the public API clear?
          6. PRODUCTION READINESS
             - Error handling comprehensive?
             - Logging appropriate?
             - No debug code left in?

          OUTPUT FORMAT:
          ## Overall Assessment
          - Implementation Quality: [excellent/good/acceptable/needs-work]
          - Recommendation: [approve/approve-with-notes/request-changes]

          ## Findings by Category
          [Group findings by the review areas above]

          ## Critical Issues (if any)
          [Must be addressed before approval]

          ## Recommendations
          [Nice-to-have improvements for future]

          ## Files Changed Summary
          [Complete list of all files modified across all tasks]
        output: "final_review"
        timeout: 600

      - id: "prepare-approval"
        agent: "superpowers:implementer"
        prompt: |
          Prepare for human approval checkpoint.

          FINAL REVIEW:
          {{final_review}}

          EXECUTION SUMMARY:
          {{execution_summary}}

          Run the full test suite to provide current test status:
          - Execute all tests
          - Report pass/fail counts
          - Note any failing tests

          Also prepare:
          - Git status showing all changes
          - Summary of branch state
          - List of commits made during implementation
        output: "approval_prep"
        timeout: 300

    approval:
      required: true
      prompt: |
        ======================================================================
        FINAL REVIEW COMPLETE - HUMAN APPROVAL REQUIRED
        ======================================================================

        The subagent-driven implementation is complete. All tasks have been:
        1. Implemented by fresh agents following TDD
        2. Reviewed for spec compliance (with iteration until approved)
        3. Reviewed for code quality (with iteration until approved)
        4. Given a final comprehensive review

        Review the final assessment above carefully.

        OPTIONS:
        - APPROVE: Accept the implementation and proceed to finish branch
        - DENY: Stop and address issues before continuing

        If you have feedback, note it before approving.
        ======================================================================
      timeout: 0
      default: "deny"

  # ============================================================================
  # STAGE 3: Finish Branch
  # Verify all tests pass and present merge options
  # ============================================================================
  - name: "finish"
    steps:
      - id: "verify-tests"
        agent: "superpowers:implementer"
        prompt: |
          FINAL VERIFICATION
          ==================
          Perform final verification before presenting merge options.

          FINAL REVIEW:
          {{final_review}}

          APPROVAL PREP:
          {{approval_prep}}

          Execute comprehensive verification:
          1. RUN FULL TEST SUITE
             - Run ALL tests (unit, integration, e2e if applicable)
             - Ensure 100% pass rate
             - Note test counts and coverage
          2. LINT AND FORMAT CHECK
             - Run linting tools
             - Check code formatting
             - Ensure no warnings
          3. BUILD CHECK (if applicable)
             - Verify project builds successfully
             - No build warnings
          4. FINAL GIT STATUS
             - Confirm all changes are committed
             - No uncommitted files
             - Branch is clean

          Report any failures. These MUST be fixed before merge.
        output: "verification_results"
        timeout: 300

      - id: "present-merge-options"
        agent: "foundation:zen-architect"
        mode: "ARCHITECT"
        prompt: |
          IMPLEMENTATION COMPLETE - MERGE OPTIONS
          =======================================

          VERIFICATION RESULTS:
          {{verification_results}}

          EXECUTION SUMMARY:
          {{execution_summary}}

          FINAL REVIEW:
          {{final_review}}

          Present the completion status and merge options.

          IF VERIFICATION PASSED:

          ## Implementation Complete

          All tasks from the implementation plan have been:
          - Implemented following TDD
          - Reviewed for spec compliance
          - Reviewed for code quality
          - Verified with passing tests

          ### Summary
          - Tasks completed: [count]
          - Tests passing: [count]
          - Average quality score: [score]/10

          ### Files Changed
          [Complete list of modified files]

          ### Next Steps - Choose One:
          1. **Merge to main branch**
             ```bash
             git checkout main
             git merge <current-branch>
             git push origin main
             ```
          2. **Create Pull Request**
             For team code review before merging.
             ```bash
             gh pr create --title "Implementation: [plan name]" --body "..."
             ```
          3. **Additional Human Review**
             Request detailed walkthrough of changes.

          ### Branch Information
          [Current branch name and commit info]

          IF VERIFICATION FAILED:

          ## Issues Found
          List what failed and needs to be addressed.
          Do NOT present merge options until issues are resolved.

          ### Required Fixes
          [List each issue that must be fixed]

          ### Next Steps
          Fix the listed issues, then re-run verification.
        output: "completion_report"
        timeout: 300
